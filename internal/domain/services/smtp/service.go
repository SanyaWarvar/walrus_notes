package smtp

import (
	"context"
	"fmt"
	"math"
	"math/rand"
	"net/smtp"
	"wn/internal/domain/dto/auth"
	"wn/internal/domain/enum"
	apperrors "wn/internal/errors"
	"wn/pkg/applogger"
	"wn/pkg/util"
	"time"
)

type Config struct {
	OwnerEmail    string
	OwnerPassword string
	Address       string
	CodeLenght    int
	CodeExp       time.Duration
	MinTTL        time.Duration
}

func NewConfig(ownerEmail, ownerPassword, addres string, codeLenght int, codeExp, minTTL time.Duration) *Config {
	return &Config{
		OwnerEmail: ownerEmail, OwnerPassword: ownerPassword, Address: addres,
		CodeLenght: codeLenght, CodeExp: codeExp, MinTTL: minTTL,
	}
}

type cacheRepo interface {
	GetConfirmCode(ctx context.Context, email string) (*auth.ConfirmationCode, bool, error)
	SaveConfirmCode(ctx context.Context, email string, item auth.ConfirmationCode, ttl *time.Duration) error
}

type Service struct {
	logger applogger.Logger

	cacheRepo cacheRepo
	cfg       *Config
}

func NewService(lgr applogger.Logger, cfg *Config, cacheRepo cacheRepo) *Service {
	return &Service{
		logger:    lgr,
		cfg:       cfg,
		cacheRepo: cacheRepo,
	}
}

func (srv *Service) SendConfirmEmailMessage(email, code, action string) error {
	baseText := `
Hello!
You ask for %s function.
Use this code: %s. 
If you don't ask this code just ignore this message. 
This message is autogenerated. Please don't answer.
	`
	text := fmt.Sprintf(baseText, action, code)
	subject := fmt.Sprintf("Email confirm code %s", code)
	return srv.SendMessage(email, text, subject)
}

func (srv *Service) SendMessage(email, messageText, title string) error {
	toEmail := email
	fromEmail := srv.cfg.OwnerEmail

	subject_body := fmt.Sprintf("Subject:%s\n\n %s", title, messageText)
	status := smtp.SendMail(
		srv.cfg.Address,
		smtp.PlainAuth("", fromEmail, srv.cfg.OwnerPassword, "smtp.gmail.com"),
		fromEmail,
		[]string{toEmail},
		[]byte(subject_body),
	)

	return status
}

func (srv *Service) GenerateConfirmCode(action enum.EmailCodeAction) *auth.ConfirmationCode {
	return &auth.ConfirmationCode{
		Code:      fmt.Sprintf("%0*d", srv.cfg.CodeLenght, rand.Intn(int(math.Pow10(srv.cfg.CodeLenght)))),
		Action:    action,
		CreatedAt: util.GetCurrentUTCTime(),
	}
}

func (srv *Service) SendConfirmEmailCode(ctx context.Context, email string, action enum.EmailCodeAction) error {
	cachedCode, ex, err := srv.cacheRepo.GetConfirmCode(ctx, email)
	if ex && (err == nil && srv.cfg.CodeExp-srv.cfg.MinTTL > util.GetCurrentUTCTime().Sub(cachedCode.CreatedAt)) {
		return apperrors.ConfirmCodeAlreadySend
	}

	newCode := srv.GenerateConfirmCode(action)
	err = srv.cacheRepo.SaveConfirmCode(ctx, email, *newCode, &srv.cfg.CodeExp)
	go func() {
		err = srv.SendConfirmEmailMessage(email, newCode.Code, action.String())
		if err != nil {
			srv.logger.Warnf("error while sending confirm email message: %s", err.Error())
		}
	}()

	return err
}

func (srv *Service) ConfirmCode(ctx context.Context, email string, code string) (*auth.ConfirmationCode, error) {
	targetCode, ex, err := srv.cacheRepo.GetConfirmCode(ctx, email)
	if err != nil {
		return nil, err
	}
	if !ex {
		return nil, apperrors.ConfirmCodeNotExist
	}
	if code != targetCode.Code {
		return nil, apperrors.ConfirmCodeIncorrect
	}
	return targetCode, nil
}
